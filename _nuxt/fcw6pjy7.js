import{h as E,m as g,r as b,s as T,i as F,n as G,p as S,q as $,l as N,a as p,v as M,x as R,y as x,z as L,w as U,b as z,e as o,d as _,t as m,F as X,A as j,o as B}from"./Ccagcpjq.js";const K=s=>s==="defer"||s===!1;function q(...s){var H;const r=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(r);let[t,c,a={}]=s;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof c!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const n=E(),w=c,h=()=>g.value,C=()=>n.isHydrating?n.payload.data[t]:n.static.data[t];a.server=a.server??!0,a.default=a.default??h,a.getCachedData=a.getCachedData??C,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??g.deep,a.dedupe=a.dedupe??"cancel";const d=a.getCachedData(t,n),P=d!=null;if(!n._asyncData[t]||!a.immediate){(H=n.payload._errors)[t]??(H[t]=g.errorValue);const l=a.deep?b:T;n._asyncData[t]={data:l(P?d:a.default()),pending:b(!P),error:F(n.payload._errors,t),status:b("idle"),_default:a.default}}const e={...n._asyncData[t]};delete e._default,e.refresh=e.execute=(l={})=>{if(n._asyncDataPromises[t]){if(K(l.dedupe??a.dedupe))return n._asyncDataPromises[t];n._asyncDataPromises[t].cancelled=!0}if(l._initial||n.isHydrating&&l._initial!==!1){const u=l._initial?d:a.getCachedData(t,n);if(u!=null)return Promise.resolve(u)}e.pending.value=!0,e.status.value="pending";const y=new Promise((u,i)=>{try{u(w(n))}catch(O){i(O)}}).then(async u=>{if(y.cancelled)return n._asyncDataPromises[t];let i=u;a.transform&&(i=await a.transform(u)),a.pick&&(i=J(i,a.pick)),n.payload.data[t]=i,e.data.value=i,e.error.value=g.errorValue,e.status.value="success"}).catch(u=>{if(y.cancelled)return n._asyncDataPromises[t];e.error.value=N(u),e.data.value=p(a.default()),e.status.value="error"}).finally(()=>{y.cancelled||(e.pending.value=!1,delete n._asyncDataPromises[t])});return n._asyncDataPromises[t]=y,n._asyncDataPromises[t]},e.clear=()=>I(n,t);const v=()=>e.refresh({_initial:!0}),D=a.server!==!1&&n.payload.serverRendered;{const l=M();if(l&&D&&a.immediate&&!l.sp&&(l.sp=[]),l&&!l._nuxtOnBeforeMountCbs){l._nuxtOnBeforeMountCbs=[];const i=l._nuxtOnBeforeMountCbs;R(()=>{i.forEach(O=>{O()}),i.splice(0,i.length)}),x(()=>i.splice(0,i.length))}D&&n.isHydrating&&(e.error.value||d!=null)?(e.pending.value=!1,e.status.value=e.error.value?"error":"success"):l&&(n.payload.serverRendered&&n.isHydrating||a.lazy)&&a.immediate?l._nuxtOnBeforeMountCbs.push(v):a.immediate&&v();const y=$();if(a.watch){const i=G(a.watch,()=>e.refresh());y&&S(i)}const u=n.hook("app:data:refresh",async i=>{(!i||i.includes(t))&&await e.refresh()});y&&S(u)}const f=Promise.resolve(n._asyncDataPromises[t]).then(()=>e);return Object.assign(f,e),f}function I(s,r){r in s.payload.data&&(s.payload.data[r]=void 0),r in s.payload._errors&&(s.payload._errors[r]=g.errorValue),s._asyncData[r]&&(s._asyncData[r].data.value=void 0,s._asyncData[r].error.value=g.errorValue,s._asyncData[r].pending.value=!1,s._asyncData[r].status.value="idle"),r in s._asyncDataPromises&&(s._asyncDataPromises[r]&&(s._asyncDataPromises[r].cancelled=!0),s._asyncDataPromises[r]=void 0)}function J(s,r){const t={};for(const c of r)t[c]=s[c];return t}function Q(){const{public:{gitHubBaseURL:s}}=L();async function r(a){return await $fetch(`repos/${a}/stats/contributors`,{baseURL:s,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}async function t(a){return await $fetch(`repos/${a}`,{baseURL:s,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}async function c(a){return await $fetch(`orgs/${a}`,{baseURL:s,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}return{getContributorStats:r,getRepository:t,getOrganization:c}}const W={class:"container"},Y={class:"organization"},Z={class:"repository"},A={class:"contributors"},k={class:"contributor"},ee=["src"],V="mouseless",te={__name:"fetching-data",async setup(s){let r,t;const{getContributorStats:c,getRepository:a,getOrganization:n}=Q(),w=`${V}/learn-nuxt`,h=b([]),C=b(),{data:d}=([r,t]=U(async()=>q("organization",async()=>await n(V))),r=await r,t(),r);return R(async()=>h.value=await a(w)),R(async()=>C.value=await c(w)),(P,e)=>{var v,D;return B(),z("div",W,[o("div",Y,[e[3]||(e[3]=o("h2",null,"Fetch Once - Server or Client",-1)),o("div",null,[e[0]||(e[0]=o("strong",null,"Organization:",-1)),_(" "+m(p(d).name)+" ",1),e[1]||(e[1]=o("br",null,null,-1)),e[2]||(e[2]=o("strong",null,"Public repositories count:",-1)),_(" "+m(p(d).public_repos),1)])]),o("div",Z,[e[7]||(e[7]=o("h2",null,"Fetch Once - Only Client",-1)),o("div",null,[e[4]||(e[4]=o("strong",null,"Repository:",-1)),_(" "+m((v=p(h))==null?void 0:v.name)+" ",1),e[5]||(e[5]=o("br",null,null,-1)),e[6]||(e[6]=o("strong",null,"Description:",-1)),_(" "+m((D=p(h))==null?void 0:D.description),1)])]),o("div",null,[e[9]||(e[9]=o("h2",null,"Fetch Twice - Server and Client",-1)),o("div",A,[(B(!0),z(X,null,j(p(C),f=>(B(),z("div",{key:f.author.login},[o("div",k,[o("img",{class:"profile-image",src:f.author.avatar_url},null,8,ee),o("h3",null,m(f.author.login),1),o("p",null,[e[8]||(e[8]=o("strong",null,"Total commits:",-1)),_(" "+m(f.total),1)])])]))),128))])])])}}};export{te as default};
