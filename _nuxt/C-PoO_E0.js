import{e as E,ar as h,r as b,as as T,at as F,R as G,au as B,av as $,W as N,aw as S,ax as x,ay as M,u as g,az as L,aq as U,c as R,a as i,b as p,t as m,F as X,x as j,o as z}from"./CY6SFX_I.js";const K=s=>s==="defer"||s===!1;function q(...s){var H;const r=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(r);let[t,c,a={}]=s;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof c!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const n=E(),w=c,v=()=>h.value,C=()=>n.isHydrating?n.payload.data[t]:n.static.data[t];a.server??(a.server=!0),a.default??(a.default=v),a.getCachedData??(a.getCachedData=C),a.lazy??(a.lazy=!1),a.immediate??(a.immediate=!0),a.deep??(a.deep=h.deep),a.dedupe??(a.dedupe="cancel");const d=a.getCachedData(t,n),P=d!=null;if(!n._asyncData[t]||!a.immediate){(H=n.payload._errors)[t]??(H[t]=h.errorValue);const l=a.deep?b:T;n._asyncData[t]={data:l(P?d:a.default()),pending:b(!P),error:F(n.payload._errors,t),status:b("idle"),_default:a.default}}const e={...n._asyncData[t]};delete e._default,e.refresh=e.execute=(l={})=>{if(n._asyncDataPromises[t]){if(K(l.dedupe??a.dedupe))return n._asyncDataPromises[t];n._asyncDataPromises[t].cancelled=!0}if(l._initial||n.isHydrating&&l._initial!==!1){const u=l._initial?d:a.getCachedData(t,n);if(u!=null)return Promise.resolve(u)}e.pending.value=!0,e.status.value="pending";const y=new Promise((u,o)=>{try{u(w(n))}catch(O){o(O)}}).then(async u=>{if(y.cancelled)return n._asyncDataPromises[t];let o=u;a.transform&&(o=await a.transform(u)),a.pick&&(o=W(o,a.pick)),n.payload.data[t]=o,e.data.value=o,e.error.value=h.errorValue,e.status.value="success"}).catch(u=>{if(y.cancelled)return n._asyncDataPromises[t];e.error.value=M(u),e.data.value=g(a.default()),e.status.value="error"}).finally(()=>{y.cancelled||(e.pending.value=!1,delete n._asyncDataPromises[t])});return n._asyncDataPromises[t]=y,n._asyncDataPromises[t]},e.clear=()=>I(n,t);const D=()=>e.refresh({_initial:!0}),_=a.server!==!1&&n.payload.serverRendered;{const l=G();if(l&&_&&a.immediate&&!l.sp&&(l.sp=[]),l&&!l._nuxtOnBeforeMountCbs){l._nuxtOnBeforeMountCbs=[];const o=l._nuxtOnBeforeMountCbs;B(()=>{o.forEach(O=>{O()}),o.splice(0,o.length)}),$(()=>o.splice(0,o.length))}_&&n.isHydrating&&(e.error.value||d!=null)?(e.pending.value=!1,e.status.value=e.error.value?"error":"success"):l&&(n.payload.serverRendered&&n.isHydrating||a.lazy)&&a.immediate?l._nuxtOnBeforeMountCbs.push(D):a.immediate&&D();const y=x();if(a.watch){const o=N(a.watch,()=>e.refresh());y&&S(o)}const u=n.hook("app:data:refresh",async o=>{(!o||o.includes(t))&&await e.refresh()});y&&S(u)}const f=Promise.resolve(n._asyncDataPromises[t]).then(()=>e);return Object.assign(f,e),f}function I(s,r){r in s.payload.data&&(s.payload.data[r]=void 0),r in s.payload._errors&&(s.payload._errors[r]=h.errorValue),s._asyncData[r]&&(s._asyncData[r].data.value=void 0,s._asyncData[r].error.value=h.errorValue,s._asyncData[r].pending.value=!1,s._asyncData[r].status.value="idle"),r in s._asyncDataPromises&&(s._asyncDataPromises[r]&&(s._asyncDataPromises[r].cancelled=!0),s._asyncDataPromises[r]=void 0)}function W(s,r){const t={};for(const c of r)t[c]=s[c];return t}function J(){const{public:{gitHubBaseURL:s}}=L();async function r(a){return await $fetch(`repos/${a}/stats/contributors`,{baseURL:s,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}async function t(a){return await $fetch(`repos/${a}`,{baseURL:s,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}async function c(a){return await $fetch(`orgs/${a}`,{baseURL:s,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}return{getContributorStats:r,getRepository:t,getOrganization:c}}const Q={class:"container"},Y={class:"organization"},Z={class:"repository"},k={class:"contributors"},A={class:"contributor"},aa=["src"],V="mouseless",ta={__name:"fetching-data",async setup(s){let r,t;const{getContributorStats:c,getRepository:a,getOrganization:n}=J(),w=`${V}/learn-nuxt`,v=b([]),C=b(),{data:d}=([r,t]=U(async()=>q("organization",async()=>await n(V))),r=await r,t(),r);return B(async()=>v.value=await a(w)),B(async()=>C.value=await c(w)),(P,e)=>{var D,_;return z(),R("div",Q,[i("div",Y,[e[3]||(e[3]=i("h2",null,"Fetch Once - Server or Client",-1)),i("div",null,[e[0]||(e[0]=i("strong",null,"Organization:",-1)),p(" "+m(g(d).name)+" ",1),e[1]||(e[1]=i("br",null,null,-1)),e[2]||(e[2]=i("strong",null,"Public repositories count:",-1)),p(" "+m(g(d).public_repos),1)])]),i("div",Z,[e[7]||(e[7]=i("h2",null,"Fetch Once - Only Client",-1)),i("div",null,[e[4]||(e[4]=i("strong",null,"Repository:",-1)),p(" "+m((D=g(v))==null?void 0:D.name)+" ",1),e[5]||(e[5]=i("br",null,null,-1)),e[6]||(e[6]=i("strong",null,"Description:",-1)),p(" "+m((_=g(v))==null?void 0:_.description),1)])]),i("div",null,[e[9]||(e[9]=i("h2",null,"Fetch Twice - Server and Client",-1)),i("div",k,[(z(!0),R(X,null,j(g(C),f=>(z(),R("div",{key:f.author.login},[i("div",A,[i("img",{class:"profile-image",src:f.author.avatar_url},null,8,aa),i("h3",null,m(f.author.login),1),i("p",null,[e[8]||(e[8]=i("strong",null,"Total commits:",-1)),p(" "+m(f.total),1)])])]))),128))])])])}}};export{ta as default};
